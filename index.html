<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>OSA</title>
        <meta name="description" content="Быстрый поиск по открытым источникам" />
        <link rel="icon" href="/favicon.ico" type="image/x-icon" />
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.blue.min.css" />
    </head>
    <body>
        <main class="container" x-data="osaApp" x-init="init()">
            <hgroup>
                <h2>OSA</h2>
                <p>Быстрый поиск по открытым источникам</p>
            </hgroup>
            <form role="search" @submit.prevent="performSearch">
                <input id="searchInput" type="search" x-model.trim="searchQuery" placeholder="Введите запрос" :disabled="isLoading" autocomplete="off" required aria-label="Поле для ввода запроса" />
                <button type="submit" :disabled="isLoading">Найти</button>
            </form>
            <section>
                <template x-if="isLoading">
                    <article aria-busy="true"></article>
                </template>
                <article x-show="isDone && !isLoading" aria-live="polite">
                    <div x-show="errorMessage" x-text="errorMessage"></div>
                    <div x-show="!errorMessage && summaryText" x-html="summaryText"></div>
                    <center x-show="!errorMessage && !summaryText">Ничего не найдено</center>
                </article>
                <article x-show="isDone && !isLoading && !errorMessage && summaryText">
                    <p><strong>Источники</strong></p>
                    <template x-if="filteredSources && filteredSources.length">
                        <ol>
                            <template x-for="source in filteredSources" :key="source.url || source.name">
                                <li>
                                    <template x-if="source.url">
                                        <a :href="source.url" target="_blank" rel="noopener noreferrer" x-text="source.url"></a>
                                    </template>
                                    <template x-if="!source.url">
                                        <span x-text="source.name"></span>
                                    </template>
                                </li>
                            </template>
                        </ol>
                    </template>
                    <details>
                        <summary>Дополнительная информация</summary>
                        <div>Время выполнения: <span x-text="elapsedTime + ' мс'"></span></div>
                        <div>Длина сводки: <span x-text="summaryLength + ' символов'"></span></div>
                        <div>Источников: <span x-text="sourceCount"></span></div>
                        <div>Уровень достоверности: <span x-text="confidenceLevel"></span></div>
                    </details>
                </article>
            </section>
        </main>
        <!-- JS библиотеки -->
        <script src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js" defer></script>
        <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js" defer></script>
        <script>
            /**
             * Базовый класс источника данных.
             */
            class DataSource {
                /**
                 * @param {string} name Название источника.
                 * @param {Object} options Настройки источника.
                 */
                constructor(name, options = {}) {
                    if (!name) {
                        throw new Error("DataSource должен иметь имя");
                    }

                    this.name = name;
                    this.retries = options.retries ?? 3;
                    this.timeout = options.timeout ?? 7000;
                    this.ttl = options.ttl ?? 300000; // Время жизни кэша, мс
                    this.maxCacheSize = options.maxCacheSize ?? 2000;
                    this.headers = options.headers ?? {};
                    this.cache = new Map();
                    this.activeRequests = new Map();
                }

                /**
                 * Получение данных из кэша.
                 * @param {string} key Ключ кэша.
                 * @return {?Object} Данные из кэша или null.
                 */
                getCache(key) {
                    const entry = this.cache.get(key);
                    if (!entry) return null;
                    if (Date.now() - entry.timestamp > this.ttl) {
                        this.cache.delete(key);
                        return null;
                    }
                    // LRU: перемещаем в конец
                    this.cache.delete(key);
                    this.cache.set(key, entry);
                    return entry.data;
                }

                /**
                 * Сохранение данных в кэш.
                 * @param {string} key Ключ кэша.
                 * @param {Object} data Данные для кэширования.
                 */
                setCache(key, data) {
                    if (this.cache.size >= this.maxCacheSize) {
                        const firstKey = this.cache.keys().next().value;
                        this.cache.delete(firstKey);
                    }
                    this.cache.set(key, { timestamp: Date.now(), data });
                }

                /**
                 * Получение JSON с обработкой таймаута и retry.
                 * @param {string} url URL запроса.
                 * @param {Object} config Конфигурация axios.
                 * @return {Promise<Object|null>} Данные JSON или null.
                 */
                async fetchJson(url, config = {}) {
                    const cached = this.getCache(url);
                    if (cached) return cached;

                    if (this.activeRequests.has(url)) {
                        return this.activeRequests.get(url);
                    }

                    const promise = (async () => {
                        let attempt = 0;
                        const baseDelay = 300;
                        while (attempt <= this.retries) {
                            try {
                                const controller = new AbortController();
                                const timeoutId = setTimeout(() => controller.abort(), this.timeout);

                                const response = await axios.get(url, {
                                    headers: this.headers,
                                    signal: controller.signal,
                                    ...config,
                                });

                                clearTimeout(timeoutId);

                                if (response.status !== 200) {
                                    throw new Error(`HTTP ${response.status}`);
                                }

                                const data = response.data;
                                this.setCache(url, data);
                                return data;
                            } catch (err) {
                                if (axios.isCancel(err) || err.name === "AbortError") {
                                    console.warn(`[DataSource] Timeout for ${url}`);
                                } else {
                                    console.error(`[DataSource] Error for ${url}: ${err.message}`);
                                }

                                attempt++;
                                if (attempt > this.retries) {
                                    return null;
                                }

                                const delay = baseDelay * Math.pow(2, attempt - 1) + Math.random() * 100; // Добавляем jitter
                                await new Promise((resolve) => setTimeout(resolve, delay));
                            }
                        }
                        return null;
                    })();

                    this.activeRequests.set(url, promise);
                    return promise.finally(() => this.activeRequests.delete(url));
                }

                /**
                 * Абстрактный метод получения данных.
                 * @param {string} query Запрос.
                 */
                async fetch(query) {
                    throw new Error("Метод fetch() должен быть переопределён в наследнике");
                }
            }

            /**
             * Источник Wikipedia.
             */
            class WikipediaSource extends DataSource {
                constructor() {
                    super("Wikipedia");
                }

                /**
                 * Получение данных из Wikipedia API.
                 * @param {string} query Запрос.
                 * @return {Promise<Object|null>}
                 */
                async fetch(query) {
                    if (!query.trim()) return null;
                    try {
                        const encodedQuery = encodeURIComponent(query);
                        const url = `https://ru.wikipedia.org/api/rest_v1/page/summary/${encodedQuery}`;
                        const data = await this.fetchJson(url);
                        if (!data || !data.extract) return null;

                        return {
                            claims: this.extractSentences(data.extract),
                            name: this.name,
                            url: `https://ru.wikipedia.org/wiki/${encodeURIComponent(data.title)}`,
                        };
                    } catch (err) {
                        console.error(`[Wikipedia] Ошибка fetch: ${err.message}`);
                        return null;
                    }
                }

                /**
                 * Разбивает текст на предложения.
                 * @param {string} text Текст.
                 * @param {number} maxSentences Максимальное количество предложений.
                 * @return {Array<string>}
                 */
                extractSentences(text, maxSentences = 20) {
                    if (!text) return [];
                    // Улучшенный сплит: учитываем аббревиатуры и т.д.
                    const sentences = text.match(/[^.!?]+[.!?]+(?:\s+|$)/g) || [];
                    return sentences
                        .map((s) => s.trim().replace(/\s+/g, " "))
                        .filter(Boolean)
                        .slice(0, maxSentences);
                }
            }

            /**
             * Класс для оценки фактов и генерации сводки.
             */
            class FactEvaluator {
                constructor({ stopWords = null, sourceWeights = null } = {}) {
                    this.wordIndex = new Map();
                    this.stopWords = new Set(stopWords || ["и", "в", "на", "с", "что", "к", "по", "для", "не", "как", "но", "за", "the", "a", "an", "of", "in", "on", "and", "or", "but", "with"]);
                    this.sourceWeights = sourceWeights || {};
                }

                /**
                 * Нормализация текста: очистка от стоп-слов и разбиение на слова.
                 * @param {string} text
                 * @return {Array<string>}
                 */
                normalizeText(text) {
                    if (!text) return [];
                    return text
                        .toLowerCase()
                        .replace(/[^\wа-яё]/gi, " ")
                        .split(/\s+/)
                        .filter((w) => w && !this.stopWords.has(w));
                }

                /**
                 * Рассчет оценки факта.
                 * @param {Set<string>} words
                 * @param {?string} source
                 * @return {number}
                 */
                calculateScore(words, source = null) {
                    const weight = this.sourceWeights[source] ?? 1.0;
                    // Улучшение: учитываем редкость слов (TF-IDF-like, но простой)
                    let score = 0;
                    words.forEach((w) => {
                        score += 1 / (this.wordIndex.get(w) ?? 1);
                    });
                    return score * weight;
                }

                /**
                 * Проверка дублирования факта.
                 * @param {Set<string>} words
                 * @return {boolean}
                 */
                isDuplicate(words) {
                    if (!words.size) return true;
                    let matches = 0;
                    words.forEach((w) => {
                        if (this.wordIndex.has(w)) matches++;
                    });
                    return matches / words.size > 0.6; // Увеличили порог для большей точности
                }

                /**
                 * Добавление слов факта в индекс.
                 * @param {Set<string>} words
                 */
                addToIndex(words) {
                    words.forEach((w) => {
                        this.wordIndex.set(w, (this.wordIndex.get(w) ?? 0) + 1);
                    });
                }

                /**
                 * Создает сводку из массива результатов.
                 * @param {Array<Object>} results
                 * @param {number} maxLength
                 * @return {string}
                 */
                createSummary(results, maxLength = 300) {
                    const allFacts = [];
                    results.filter(Boolean).forEach((r) => {
                        if (r?.claims?.length) {
                            r.claims.forEach((cl) => {
                                if (cl) allFacts.push({ fact: cl, source: r.name });
                            });
                        }
                    });

                    if (!allFacts.length) return "";

                    // Нормализация и скоринг
                    const scored = allFacts
                        .map((i) => {
                            const words = new Set(this.normalizeText(i.fact));
                            return { ...i, words, score: this.calculateScore(words, i.source) };
                        })
                        .sort((a, b) => b.score - a.score);

                    this.wordIndex.clear();
                    let summary = "";
                    const used = [];

                    for (const i of scored) {
                        if (!i.words.size) continue;
                        if (this.isDuplicate(i.words)) continue;

                        const conflict = this.calculateConflict(
                            i.words,
                            used.map((f) => f.words)
                        );
                        if (conflict > 0.5) continue;

                        const candidate = (summary ? " " : "") + i.fact;
                        if ((summary + candidate).length > maxLength) break;

                        summary += candidate;
                        this.addToIndex(i.words);
                        used.push(i);
                    }

                    // Удаляем trailing точку если нужно
                    return summary.trim().replace(/[.!?]$/, "");
                }

                /**
                 * Рассчет конфликта между фактом и существующими фактами.
                 * @param {Set<string>} factWords
                 * @param {Array<Set<string>>} existingFacts
                 * @return {number}
                 */
                calculateConflict(factWords, existingFacts) {
                    if (!existingFacts.length) return 0;
                    let similaritySum = 0;
                    for (const words of existingFacts) {
                        const inter = new Set([...factWords].filter((x) => words.has(x)));
                        similaritySum += inter.size / Math.min(factWords.size, words.size);
                    }
                    // Средняя схожесть; conflict если высокая (дубликат-like)
                    return similaritySum / existingFacts.length;
                }

                /**
                 * Рассчет доверия к фактам.
                 * @param {Array<Object>} results
                 * @return {number} 0–1
                 */
                calculateConfidence(results) {
                    if (!Array.isArray(results) || !results.length) return 0;

                    let totalScore = 0;
                    let totalWeight = 0;
                    let uniqueSources = new Set();

                    results.forEach((r) => {
                        if (!r?.claims?.length) return;
                        const w = this.sourceWeights[r.name] ?? 1.0;
                        uniqueSources.add(r.name);
                        r.claims.forEach((cl) => {
                            const words = new Set(this.normalizeText(cl));
                            totalScore += this.calculateScore(words, r.name);
                            totalWeight += w;
                        });
                    });

                    if (totalWeight === 0) return 0;

                    // Улучшение: учитываем разнообразие источников
                    const diversityBonus = Math.min(1, uniqueSources.size / 5);
                    return Math.min(1, (totalScore / totalWeight) * 0.1 * (1 + diversityBonus));
                }

                /**
                 * Генерация сводки и метаданных.
                 * @param {Array<Object>} results
                 * @param {number} maxLength
                 * @return {Object} {summaryText, confidenceLevel, sourceCount, summaryLength}
                 */
                summarizeResults(results, maxLength = 300) {
                    const summaryText = this.createSummary(results, maxLength);
                    const confidence = this.calculateConfidence(results);
                    const sourceCount = new Set(results.filter((r) => r && r.claims?.length).map((r) => r.name)).size;
                    const summaryLength = summaryText.length;

                    return {
                        summaryText,
                        confidenceLevel: (confidence * 100).toFixed(0) + "%",
                        sourceCount,
                        summaryLength,
                    };
                }
            }

            /**
             * Основной класс приложения OSA.
             */
            class OsaAppClass {
                constructor({
                    sources = [new WikipediaSource()],
                    evaluator = new FactEvaluator({
                        sourceWeights: {
                            Wikipedia: 1.3,
                        },
                    }),
                } = {}) {
                    this.searchQuery = "";
                    this.isLoading = false;
                    this.isDone = false;
                    this.errorMessage = "";
                    this.summaryText = "";
                    this.filteredSources = [];
                    this.confidenceLevel = "";
                    this.sourceCount = 0;
                    this.summaryLength = 0;
                    this.elapsedTime = 0;
                    this.sources = sources;
                    this.evaluator = evaluator;
                    this.cache = new Map();
                    this.maxCacheSize = 100; // Ограничиваем кэш приложения
                }

                resetState() {
                    this.errorMessage = "";
                    this.summaryText = "";
                    this.filteredSources = [];
                    this.confidenceLevel = "";
                    this.sourceCount = 0;
                    this.summaryLength = 0;
                    this.isDone = false;
                    this.elapsedTime = 0;
                }

                showError(msg) {
                    this.errorMessage = msg;
                    this.summaryText = "";
                    this.isDone = true;
                    this.isLoading = false;
                }

                async safeFetchSource(src, query) {
                    try {
                        const result = await src.fetch(query);
                        if (!result) {
                            console.warn(`[OsaApp] Источник ${src.name} вернул пустой результат`);
                        }
                        return result;
                    } catch (err) {
                        console.error(`[OsaApp] Ошибка источника ${src.name}: ${err.message}`);
                        return null;
                    }
                }

                getFallbackSummary(results) {
                    for (const r of results) {
                        if (r?.claims?.length) return r.claims.join(" ");
                    }
                    return "";
                }

                async performSearch() {
                    const query = this.searchQuery.trim();
                    if (!query) {
                        this.showError("Пожалуйста, введите запрос");
                        return;
                    }

                    this.resetState();
                    this.isLoading = true;
                    const startTime = performance.now();

                    if (this.cache.has(query)) {
                        const cached = this.cache.get(query);
                        Object.assign(this, cached);
                        this.isDone = true;
                        this.isLoading = false;
                        return;
                    }

                    try {
                        const results = await Promise.all(this.sources.map((s) => this.safeFetchSource(s, query)));
                        const { summaryText, confidenceLevel, sourceCount, summaryLength } = this.evaluator.summarizeResults(results);

                        this.summaryText = summaryText || this.getFallbackSummary(results);
                        this.elapsedTime = Math.round(performance.now() - startTime);
                        this.filteredSources = results.filter((r) => r && r.claims?.length > 0);
                        this.confidenceLevel = confidenceLevel;
                        this.sourceCount = sourceCount;
                        this.summaryLength = summaryText.length; // Используем реальную длину

                        // Кэшируем
                        if (this.cache.size >= this.maxCacheSize) {
                            const firstKey = this.cache.keys().next().value;
                            this.cache.delete(firstKey);
                        }
                        this.cache.set(query, {
                            summaryText: this.summaryText,
                            elapsedTime: this.elapsedTime,
                            filteredSources: this.filteredSources,
                            confidenceLevel: this.confidenceLevel,
                            sourceCount: this.sourceCount,
                            summaryLength: this.summaryLength,
                        });
                    } catch (err) {
                        this.showError("Произошла ошибка при поиске. Попробуйте ещё раз.");
                        console.error("OsaApp performSearch error:", err);
                    } finally {
                        this.isLoading = false;
                        this.isDone = true;
                    }
                }

                init() {}
            }

            document.addEventListener("alpine:init", () => {
                Alpine.data("osaApp", () => new OsaAppClass());
            });
        </script>
    </body>
</html>
